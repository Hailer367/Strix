name: Strix - Autonomous Security Agent (Idle Mode)

on:
  workflow_dispatch:
    inputs:
      decryption_password:
        description: 'Password to decrypt QWEN_TOKENS'
        required: true
        type: string
      model:
        description: 'AI Model to use'
        required: false
        default: 'qwen3-coder-plus'
        type: choice
        options:
          - 'qwen3-coder-plus'
          - 'qwen3-coder-flash'
          - 'qwen3-max'
          - 'qwen-plus'
          - 'qwen-turbo'
          - 'qwen2.5-coder-32b-instruct'

env:
  CLIPROXY_PORT: '8317'
  STRIX_IMAGE: ghcr.io/89pl/strix-sandbox:latest

jobs:
  strix-runtime:
    name: Strix Infrastructure Environment
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Setup Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Decrypt Qwen Tokens
        id: decrypt
        run: |
          set -euo pipefail
          echo "::group::Decrypting Qwen tokens"
          if [ -z "${{ secrets.QWEN_TOKENS }}" ]; then
            echo "::error::QWEN_TOKENS secret is not set"
            exit 1
          fi
          mkdir -p ~/.cli-proxy-api
          cd ~/.cli-proxy-api
          echo "${{ secrets.QWEN_TOKENS }}" | base64 -d > qwen-tokens.enc
          if ! echo "${{ github.event.inputs.decryption_password }}" | openssl enc -aes-256-cbc -d -salt -pbkdf2 -in qwen-tokens.enc -out qwen-tokens.tar.gz -pass stdin 2>/dev/null; then
            echo "::error::Failed to decrypt tokens. Invalid password"
            exit 1
          fi
          tar -xzf qwen-tokens.tar.gz
          TOKEN_COUNT=$(find . -maxdepth 1 -name 'qwen-*.json' | wc -l)
          echo "Successfully decrypted $TOKEN_COUNT Qwen account(s)"
          echo "token_count=$TOKEN_COUNT" >> "$GITHUB_OUTPUT"
          rm -f qwen-tokens.enc qwen-tokens.tar.gz
          echo "::endgroup::"

      - name: Install CLIProxyAPI
        run: |
          set -euo pipefail
          echo "::group::Installing CLIProxyAPI"
          git clone --depth 1 https://github.com/router-for-me/CLIProxyAPI.git /tmp/CLIProxyAPI
          cd /tmp/CLIProxyAPI
          go build -o cli-proxy-api ./cmd/server
          sudo mv cli-proxy-api /usr/local/bin/
          echo "CLIProxyAPI installed"
          echo "::endgroup::"

      - name: Install SAST Tools
        run: |
          set -euo pipefail
          echo "::group::Installing SAST Tools"
          pip install semgrep bandit trufflehog detect-secrets checkov safety pip-audit 2>/dev/null || true
          curl -sSfL https://github.com/gitleaks/gitleaks/releases/download/v8.18.4/gitleaks_8.18.4_linux_x64.tar.gz | tar xz -C /usr/local/bin gitleaks 2>/dev/null || true
          echo "::endgroup::"

      - name: Install DAST Tools
        run: |
          set -euo pipefail
          echo "::group::Installing DAST Tools"
          sudo apt-get update -qq && sudo apt-get install -y -qq nmap nikto dnsutils whois jq curl wget unzip || true
          curl -sSfL https://github.com/projectdiscovery/nuclei/releases/download/v3.2.9/nuclei_3.2.9_linux_amd64.zip -o /tmp/nuclei.zip && unzip -q /tmp/nuclei.zip -d /usr/local/bin 2>/dev/null || true
          nuclei -update-templates 2>/dev/null || true
          curl -sSfL https://github.com/ffuf/ffuf/releases/download/v2.1.0/ffuf_2.1.0_linux_amd64.tar.gz | tar xz -C /usr/local/bin ffuf 2>/dev/null || true
          pip install sqlmap dirsearch 2>/dev/null || true
          echo "::endgroup::"

      - name: Configure CLIProxyAPI
        run: |
          set -euo pipefail
          echo "::group::Configuring CLIProxyAPI"
          AUTH_DIR="$HOME/.cli-proxy-api"
          cat > "$AUTH_DIR/config.yaml" << EOF
          host: "127.0.0.1"
          port: 8317
          auth-dir: "$AUTH_DIR"
          debug: true
          logging-to-file: true
          request-retry: 5
          max-retry-interval: 60
          quota-exceeded:
            switch-project: true
            switch-preview-model: true
          routing:
            strategy: "round-robin"
          EOF
          echo "::endgroup::"

      - name: Start CLIProxyAPI Server
        id: cliproxy
        run: |
          set -euo pipefail
          echo "::group::Starting CLIProxyAPI Server"
          AUTH_DIR="$HOME/.cli-proxy-api"
          cd "$AUTH_DIR"
          nohup cli-proxy-api -config config.yaml > cliproxy.log 2>&1 &
          SERVER_PID=$!
          echo "$SERVER_PID" > cliproxy.pid
          sleep 10
          
          # Wait for server ready
          for i in {1..20}; do
            if curl -s "http://127.0.0.1:${{ env.CLIPROXY_PORT }}/v1/models" > /dev/null 2>&1; then
              echo "CLIProxyAPI is ready!"
              break
            fi
            sleep 2
          done
          
          ENDPOINT="http://127.0.0.1:${{ env.CLIPROXY_PORT }}/v1"
          echo "endpoint=$ENDPOINT" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"

      - name: Pull Strix Sandbox Image
        run: |
          echo "::group::Pulling latest Strix Sandbox image"
          docker pull ${{ env.STRIX_IMAGE }}
          echo "::endgroup::"

      - name: Install Strix from Source
        run: |
          set -euo pipefail
          echo "::group::Installing Strix from Source (https://github.com/89pl/Strix)"
          git clone --depth 1 https://github.com/89pl/Strix /tmp/strix-source
          cd /tmp/strix-source
          pip install -e .
          pip install jinja2 httpx tenacity requests pydantic rich docker textual xmltodict aiohttp
          echo "Strix installed from source"
          echo "::endgroup::"

      - name: Setup Direct API Mode Environment
        run: |
          echo "CLIPROXY_ENDPOINT=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          echo "CLIPROXY_MODEL=${{ github.event.inputs.model }}" >> "$GITHUB_ENV"
          echo "STRIX_LLM=${{ github.event.inputs.model }}" >> "$GITHUB_ENV"
          echo "LLM_API_BASE=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          echo "OPENAI_API_KEY=cliproxy-direct-mode" >> "$GITHUB_ENV"
          echo "OPENAI_API_BASE=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          echo "STRIX_DIRECT_API_MODE=true" >> "$GITHUB_ENV"
          echo "DISCORD_BOT_TOKEN=${{ secrets.DISCORD_BOT_TOKEN }}" >> "$GITHUB_ENV"
          echo "DISCORD_CHANNEL_ID=${{ secrets.DISCORD_CHANNEL_ID }}" >> "$GITHUB_ENV"

      - name: Install Discord Bot Dependencies
        run: |
          echo "::group::Installing Discord Bot Dependencies"
          pip install discord.py
          echo "::endgroup::"

      - name: Create Discord Bot Script
        run: |
          echo '#!/usr/bin/env python3' > /tmp/discord_bot.py
          echo 'import asyncio' >> /tmp/discord_bot.py
          echo 'import discord' >> /tmp/discord_bot.py
          echo 'from discord.ext import commands' >> /tmp/discord_bot.py
          echo 'import os' >> /tmp/discord_bot.py
          echo 'import subprocess' >> /tmp/discord_bot.py
          echo 'import json' >> /tmp/discord_bot.py
          echo 'import tempfile' >> /tmp/discord_bot.py
          echo 'import threading' >> /tmp/discord_bot.py
          echo 'import time' >> /tmp/discord_bot.py
          echo 'from datetime import datetime' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '# Initialize bot' >> /tmp/discord_bot.py
          echo 'intents = discord.Intents.default()' >> /tmp/discord_bot.py
          echo 'intents.message_content = True' >> /tmp/discord_bot.py
          echo 'bot = commands.Bot(command_prefix=\'!\', intents=intents)' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '# Global variables to maintain Strix context' >> /tmp/discord_bot.py
          echo 'current_job_id = None' >> /tmp/discord_bot.py
          echo 'job_results = {}' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '@bot.event' >> /tmp/discord_bot.py
          echo 'async def on_ready():' >> /tmp/discord_bot.py
          echo '    print(f\'Discord bot is ready. Logged in as {bot.user}\')' >> /tmp/discord_bot.py
          echo '    channel_id = int(os.getenv(\'DISCORD_CHANNEL_ID\', \'0\'))' >> /tmp/discord_bot.py
          echo '    if channel_id != 0:' >> /tmp/discord_bot.py
          echo '        channel = bot.get_channel(channel_id)' >> /tmp/discord_bot.py
          echo '        if channel:' >> /tmp/discord_bot.py
          echo '            await channel.send(f"âœ… Strix Security Agent is online and ready!\\nModel: {os.getenv(\'CLIPROXY_MODEL\', \'unknown\')}\\nAccounts: {os.getenv(\'ACCOUNTS_COUNT\', \'0\')}")' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '@bot.command(name=\'scan\')' >> /tmp/discord_bot.py
          echo 'async def scan(ctx, target: str = None):' >> /tmp/discord_bot.py
          echo '    """Initiate a security scan on the specified target"""' >> /tmp/discord_bot.py
          echo '    if not target:' >> /tmp/discord_bot.py
          echo '        await ctx.send("âŒ Please specify a target to scan. Usage: `!scan <target>`")' >> /tmp/discord_bot.py
          echo '        return' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '    # Validate target format to prevent command injection' >> /tmp/discord_bot.py
          echo '    if not validate_target(target):' >> /tmp/discord_bot.py
          echo '        await ctx.send("âŒ Invalid target format. Only domains, IPs, and URLs are allowed.")' >> /tmp/discord_bot.py
          echo '        return' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '    # Create a new job' >> /tmp/discord_bot.py
          echo '    job_id = f"job_{int(time.time())}"' >> /tmp/discord_bot.py
          echo '    global current_job_id' >> /tmp/discord_bot.py
          echo '    current_job_id = job_id' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '    # Send initial message' >> /tmp/discord_bot.py
          echo '    msg = await ctx.send(f"ğŸ” Starting security scan on `{target}` (Job ID: {job_id})...")' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '    # Run the scan in a separate thread to not block the bot' >> /tmp/discord_bot.py
          echo '    def run_scan():' >> /tmp/discord_bot.py
          echo '        try:' >> /tmp/discord_bot.py
          echo '            # Create a temporary directory for scan results' >> /tmp/discord_bot.py
          echo '            with tempfile.TemporaryDirectory() as temp_dir:' >> /tmp/discord_bot.py
          echo '                # Determine which scanning tool to use based on target type' >> /tmp/discord_bot.py
          echo '                if target.startswith((\'http://\', \'https://\')):' >> /tmp/discord_bot.py
          echo '                    # Use a DAST tool like nikto or nmap for web apps' >> /tmp/discord_bot.py
          echo '                    cmd = [' >> /tmp/discord_bot.py
          echo '                        \'docker\', \'run\', \'--rm\',' >> /tmp/discord_bot.py
          echo '                        \'-v\', f\'{temp_dir}:/results\',' >> /tmp/discord_bot.py
          echo '                        \'-e\', f\'TARGET={target}\',' >> /tmp/discord_bot.py
          echo '                        \'-e\', \'CLIPROXY_ENDPOINT=\' + os.getenv(\'CLIPROXY_ENDPOINT\'),' >> /tmp/discord_bot.py
          echo '                        \'-e\', \'CLIPROXY_MODEL=\' + os.getenv(\'CLIPROXY_MODEL\'),' >> /tmp/discord_bot.py
          echo '                        os.getenv(\'STRIX_IMAGE\'),' >> /tmp/discord_bot.py
          echo '                        \'nuclei\', \'-u\', target, \'-o\', f\'/results/{job_id}_nuclei_results.txt\'' >> /tmp/discord_bot.py
          echo '                    ]' >> /tmp/discord_bot.py
          echo '                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)  # 30 minute timeout' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '                    # Also run additional scans' >> /tmp/discord_bot.py
          echo '                    subprocess.run([' >> /tmp/discord_bot.py
          echo '                        \'docker\', \'run\', \'--rm\',' >> /tmp/discord_bot.py
          echo '                        \'-v\', f\'{temp_dir}:/results\',' >> /tmp/discord_bot.py
          echo '                        os.getenv(\'STRIX_IMAGE\'),' >> /tmp/discord_bot.py
          echo '                        \'nmap\', \'-sV\', target, \'-oN\', f\'/results/{job_id}_nmap_results.txt\'' >> /tmp/discord_bot.py
          echo '                    ], timeout=1800)' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '                else:' >> /tmp/discord_bot.py
          echo '                    # Use SAST tools for code repositories' >> /tmp/discord_bot.py
          echo '                    cmd = [' >> /tmp/discord_bot.py
          echo '                        \'docker\', \'run\', \'--rm\',' >> /tmp/discord_bot.py
          echo '                        \'-v\', f\'{temp_dir}:/results\',' >> /tmp/discord_bot.py
          echo '                        \'-e\', \'CLIPROXY_ENDPOINT=\' + os.getenv(\'CLIPROXY_ENDPOINT\'),' >> /tmp/discord_bot.py
          echo '                        \'-e\', \'CLIPROXY_MODEL=\' + os.getenv(\'CLIPROXY_MODEL\'),' >> /tmp/discord_bot.py
          echo '                        os.getenv(\'STRIX_IMAGE\'),' >> /tmp/discord_bot.py
          echo '                        \'semgrep\', \'--config=auto\', target, \'--json\', f\'-o\', f\'/results/{job_id}_semgrep_results.json\'' >> /tmp/discord_bot.py
          echo '                    ]' >> /tmp/discord_bot.py
          echo '                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '                # Read results' >> /tmp/discord_bot.py
          echo '                results = {}' >> /tmp/discord_bot.py
          echo '                for filename in os.listdir(temp_dir):' >> /tmp/discord_bot.py
          echo '                    filepath = os.path.join(temp_dir, filename)' >> /tmp/discord_bot.py
          echo '                    with open(filepath, \'r\') as f:' >> /tmp/discord_bot.py
          echo '                        results[filename] = f.read()' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '                # Store results' >> /tmp/discord_bot.py
          echo '                job_results[job_id] = {' >> /tmp/discord_bot.py
          echo '                    \'target\': target,' >> /tmp/discord_bot.py
          echo '                    \'timestamp\': datetime.now().isoformat(),' >> /tmp/discord_bot.py
          echo '                    \'results\': results,' >> /tmp/discord_bot.py
          echo '                    \'status\': \'completed\'' >> /tmp/discord_bot.py
          echo '                }' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '                # Send results to Discord' >> /tmp/discord_bot.py
          echo '                asyncio.run_coroutine_threadsafe(send_results_to_discord(ctx, job_id, results), bot.loop)' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '        except subprocess.TimeoutExpired:' >> /tmp/discord_bot.py
          echo '            job_results[job_id] = {' >> /tmp/discord_bot.py
          echo '                \'target\': target,' >> /tmp/discord_bot.py
          echo '                \'timestamp\': datetime.now().isoformat(),' >> /tmp/discord_bot.py
          echo '                \'results\': {\'error\': \'Scan timed out after 30 minutes\'],' >> /tmp/discord_bot.py
          echo '                \'status\': \'timeout\'' >> /tmp/discord_bot.py
          echo '            }' >> /tmp/discord_bot.py
          echo '            asyncio.run_coroutine_threadsafe(ctx.send(f"â° Scan for `{target}` timed out after 30 minutes."), bot.loop)' >> /tmp/discord_bot.py
          echo '        except Exception as e:' >> /tmp/discord_bot.py
          echo '            job_results[job_id] = {' >> /tmp/discord_bot.py
          echo '                \'target\': target,' >> /tmp/discord_bot.py
          echo '                \'timestamp\': datetime.now().isoformat(),' >> /tmp/discord_bot.py
          echo '                \'results\': {\'error\': str(e)},' >> /tmp/discord_bot.py
          echo '                \'status\': \'error\'' >> /tmp/discord_bot.py
          echo '            }' >> /tmp/discord_bot.py
          echo '            asyncio.run_coroutine_threadsafe(ctx.send(f"âŒ Error during scan: {str(e)}"), bot.loop)' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '    # Run the scan in a separate thread' >> /tmp/discord_bot.py
          echo '    scan_thread = threading.Thread(target=run_scan)' >> /tmp/discord_bot.py
          echo '    scan_thread.start()' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo 'def validate_target(target):' >> /tmp/discord_bot.py
          echo '    """Validate target format to prevent command injection"""' >> /tmp/discord_bot.py
          echo '    import re' >> /tmp/discord_bot.py
          echo '    # Allow domains, IPs, and URLs' >> /tmp/discord_bot.py
          echo '    domain_pattern = r\'^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9](\\.[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])*\\.?$\'' >> /tmp/discord_bot.py
          echo '    ip_pattern = r\'^(\\d{1,3}\\.){3}\\d{1,3}$\'' >> /tmp/discord_bot.py
          echo '    url_pattern = r\'^https?://[^\\s/$.?#].[^\\s]*$\'' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '    return (' >> /tmp/discord_bot.py
          echo '        re.match(domain_pattern, target) is not None or' >> /tmp/discord_bot.py
          echo '        re.match(ip_pattern, target) is not None or' >> /tmp/discord_bot.py
          echo '        re.match(url_pattern, target) is not None' >> /tmp/discord_bot.py
          echo '    )' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo 'async def send_results_to_discord(ctx, job_id, results):' >> /tmp/discord_bot.py
          echo '    """Send scan results to Discord"""' >> /tmp/discord_bot.py
          echo '    try:' >> /tmp/discord_bot.py
          echo '        total_chars = 0' >> /tmp/discord_bot.py
          echo '        for filename, content in results.items():' >> /tmp/discord_bot.py
          echo '            # Limit message length to Discord\'s 2000 character limit' >> /tmp/discord_bot.py
          echo '            content_str = str(content)' >> /tmp/discord_bot.py
          echo '            if len(content_str) > 1900:  # Leave room for prefix' >> /tmp/discord_bot.py
          echo '                content_str = content_str[:1900] + "... (truncated)"' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '            message = f"ğŸ“„ **{filename}**\\n```\\n{content_str}\\n```"' >> /tmp/discord_bot.py
          echo '            await ctx.send(message)' >> /tmp/discord_bot.py
          echo '            total_chars += len(message)' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '            # If we\'re approaching rate limits, add a small delay' >> /tmp/discord_bot.py
          echo '            if total_chars > 5000:' >> /tmp/discord_bot.py
          echo '                await asyncio.sleep(1)' >> /tmp/discord_bot.py
          echo '                total_chars = 0' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '        await ctx.send(f"âœ… Scan job {job_id} completed for `{results.get(\'target\', \'unknown\')}")"' >> /tmp/discord_bot.py
          echo '    except Exception as e:' >> /tmp/discord_bot.py
          echo '        await ctx.send(f"âŒ Error sending results to Discord: {str(e)}")' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '@bot.command(name=\'status\')' >> /tmp/discord_bot.py
          echo 'async def status(ctx):' >> /tmp/discord_bot.py
          echo '    """Get the status of the current scan job"""' >> /tmp/discord_bot.py
          echo '    if current_job_id:' >> /tmp/discord_bot.py
          echo '        status_info = job_results.get(current_job_id, {\'status\': \'running\'})' >> /tmp/discord_bot.py
          echo '        await ctx.send(f"ğŸ“Š Current job {current_job_id}: {status_info.get(\'status\', \'running\')}")' >> /tmp/discord_bot.py
          echo '    else:' >> /tmp/discord_bot.py
          echo '        await ctx.send("â„¹ï¸ No active scan jobs")' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '@bot.command(name=\'help\')' >> /tmp/discord_bot.py
          echo 'async def help_command(ctx):' >> /tmp/discord_bot.py
          echo '    """Show available commands"""' >> /tmp/discord_bot.py
          echo '    help_text = """' >> /tmp/discord_bot.py
          echo 'ğŸ›¡ï¸ **Strix Security Agent Commands:**' >> /tmp/discord_bot.py
          echo 'â€¢ `!scan <target>` - Initiate a security scan on the specified target' >> /tmp/discord_bot.py
          echo 'â€¢ `!status` - Check the status of the current scan job' >> /tmp/discord_bot.py
          echo 'â€¢ `!help` - Show this help message' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo 'Supported targets:' >> /tmp/discord_bot.py
          echo 'â€¢ Domains: example.com' >> /tmp/discord_bot.py
          echo 'â€¢ IP addresses: 192.168.1.1' >> /tmp/discord_bot.py
          echo 'â€¢ URLs: https://example.com"""' >> /tmp/discord_bot.py
          echo '    await ctx.send(help_text)' >> /tmp/discord_bot.py
          echo '' >> /tmp/discord_bot.py
          echo '# Run the bot' >> /tmp/discord_bot.py
          echo 'if __name__ == "__main__":' >> /tmp/discord_bot.py
          echo '    bot.run(os.getenv(\'DISCORD_BOT_TOKEN\'))' >> /tmp/discord_bot.py

      - name: Run Discord Bot
        timeout-minutes: 360
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘         STRIX DISCORD INTEGRATION ACTIVATED                  â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  CLIProxyAPI: ${{ steps.cliproxy.outputs.endpoint }}"
          echo "â•‘  Model: ${{ github.event.inputs.model }}"
          echo "â•‘  Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "â•‘  Mode: Direct API (STRIX_DIRECT_API_MODE=true)"
          echo "â•‘  Discord Integration: ACTIVE                                â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Discord bot is now running and awaiting commands...         â•‘"
          echo "â•‘  Use !scan <target> to initiate security scans               â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          # Pass the accounts count to the bot
          echo "ACCOUNTS_COUNT=${{ steps.decrypt.outputs.token_count }}" >> "$GITHUB_ENV"

          # Run the Discord bot
          python /tmp/discord_bot.py

      - name: Stop CLIProxyAPI Server
        if: always()
        run: |
          AUTH_DIR="$HOME/.cli-proxy-api"
          if [ -f "$AUTH_DIR/cliproxy.pid" ]; then
            kill $(cat "$AUTH_DIR/cliproxy.pid") 2>/dev/null || true
          fi
          rm -rf "$AUTH_DIR"/qwen-*.json
